#!/usr/bin/env python
#
# Do a safe "git pull" (do not replace anything and do not do anything
# if some files were modified in the current local repository).
#
# Author: James Cherti
# URL: https://github.com/jamescherti/jc-dev
#
# Distributed under terms of the MIT license.
#
# Copyright (C) 2004-2026 James Cherti
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

"Update the Git repository."


import argparse
import os
import shlex
import shutil
import subprocess
import textwrap
from pathlib import Path
from subprocess import PIPE, CalledProcessError, Popen
from typing import List, Tuple, Union

VERBOSE = True


def run_simple(cmd: Union[List[str], str],
               **kwargs) -> Tuple[List[str], List[str]]:
    """
    Executes a command and returns stdout and stderr as separate lists of
    strings.

    :param cmd: Command to be executed. Can be a list or a string.
    :param kwargs: Additional keyword arguments for Popen.
    :return: Tuple containing two lists: stdout lines and stderr lines.
    """
    full_cmd = shlex.split(cmd) if isinstance(cmd, str) else cmd

    with Popen(full_cmd, stdout=PIPE, stderr=PIPE, text=True,
               **kwargs) as process:
        stdout, stderr = process.communicate()

    stdout_lines = stdout.splitlines()
    stderr_lines = stderr.splitlines()

    if process.returncode != 0:
        raise CalledProcessError(returncode=process.returncode,
                                 cmd=cmd,
                                 output=stdout,
                                 stderr=stderr)

    return (stdout_lines, stderr_lines)


class GitEnsureError(Exception):
    """Exception raised by Downloader()."""


class GitRevisionDoesNotExist(Exception):
    """The Git revision does not exist."""


class GitRemoteError(Exception):
    """The git remote does not exist."""


class GitUpdate():
    """Clone or update a Git repository."""

    def __init__(self, repo_path: os.PathLike, repo_uri: str = ""):
        self._git_fetch_origin_done = False

        self.branch_commit_ref = None
        self.is_branch = False

        self.env = os.environ.copy()
        self.env["GIT_TERMINAL_PROMPT"] = "0"
        self.env["GIT_PAGER"] = ""

        self.git_local_dir = Path(repo_path)
        self.current_branch = None
        self.current_commit_ref = None

        self.repo_uri_key = "git"

        os.chdir(repo_path)
        if not repo_uri:
            repo_uri = self._git_get_remote_url()

        self.data = {"delete": False,
                     "git": repo_uri,
                     "revision": "",
                     "git_pull": True,
                     "exec_before": [],
                     "exec_after": [],
                     "git_clone_args": [],
                     "git_merge_args": []}

        self.error = False
        self.changed = False
        self.output = ""

        self.indent = 4
        self.indent_spaces = " " * self.indent

    def message(self, string: str):
        print(string, end="")

    def update(self):
        """Clone or update a Git repository."""
        is_clone = False
        if not self.git_local_dir.exists():
            is_clone = True

        # Result (string)
        if self.data["delete"]:
            update_type = "DELETE"
        elif is_clone:
            update_type = "CLONE"
        else:
            update_type = "UPDATE"

        git_local_dir_name = Path(self.git_local_dir).absolute().name
        self.message(f"[GIT {update_type}] {git_local_dir_name} "
                     f"(upstream/origin: {self.data[self.repo_uri_key]})"
                     + (f" (Ref: {self.data['revision']})"
                        if self.data["revision"] else "") + "\n")

        try:
            # Delete
            if self.data["delete"]:
                self._repo_delete()

            # Clone
            elif is_clone:
                self._repo_clone()

            # Update
            if self.git_local_dir.is_dir():
                do_git_fetch = self.data["git_pull"]

                # Pre exec
                if do_git_fetch:
                    self._update_current_branch_name()

                self._repo_fix_remote_origin()
                self._exec_before(cwd=self.git_local_dir)

                if not self.data["revision"]:
                    self.data["revision"] = self._run_get_firstline(
                        "git symbolic-ref --short HEAD")
                    if not self.data["revision"]:
                        raise GitEnsureError(
                            "Unable to determine the default origin branch"
                        )

                    self.message(self.indent_spaces +
                                 "[INFO] Revision: " +
                                 self.data["revision"] + "\n")

                if do_git_fetch:
                    git_fetch_done = self._repo_fetch()

                self._repo_fix_branch()

                if git_fetch_done:
                    self._git_merge()

                if self.get_changed():
                    self._exec_after(cwd=self.git_local_dir)
        except GitEnsureError as err:
            self.set_error(True)
            self.message(self.indent_spaces + "[ERROR] " + str(err) + "\n")
        except subprocess.CalledProcessError as err:
            self.set_error(True)
            self.message(self.indent_spaces + "[ERROR] " + str(err) + "\n")
            self.message(self.indent_spaces
                         + textwrap.indent(err.stdout, " " * self.indent)
                         + "\n"
                         + textwrap.indent(err.stderr, " " * self.indent))

        if not self.is_error() and not self.is_changed():
            self.message(self.indent_spaces + "[INFO] Nothing to do.\n")

        return self.data

    def _run_get_firstline(self, *args, **kwargs):
        stdout, _ = self._run(*args, **kwargs)
        try:
            return stdout[0]
        except IndexError:
            return ""

    def _run(self, cmd: Union[List[str], str],
             cwd: Union[None, os.PathLike] = None,
             env: Union[None, dict] = None,
             **kwargs) -> Tuple[List[str], List[str]]:
        """
        Executes a command and returns stdout and stderr as separate lists of
        strings.

        :param cmd: Command to be executed. Can be a list or a string.
        :param kwargs: Additional keyword arguments for Popen.
        :cwd: Current working directory.
        :env: Environment variables.
        :return: Tuple containing two lists: stdout lines and stderr lines.
        """
        if not cwd:
            cwd = self.git_local_dir
        if not env:
            env = self.env
        return run_simple(cmd=cmd, env=env, cwd=cwd, **kwargs)

    def _git_ref(self, cwd: Union[None, Path] = None) -> str:
        """Get the commit revision of HEAD.

        The command will fail if the branch is detached.
        """
        cmd = ["git", "show-ref", "--head", "--verify", "HEAD"]
        try:
            stdout, _ = self._run(cmd, cwd=cwd)
            output = stdout[0].split(" ")[0]
        except IndexError:
            return ""
        return output

    def _update_current_branch_name(self):
        try:
            # This returns the branch name
            stdout, _ = self._run(["git", "symbolic-ref", "--short", "HEAD"])
            self.current_branch = stdout[0]
            self.is_branch = True
        except (IndexError, subprocess.CalledProcessError):
            # Not a symbolic ref
            self.current_branch = None

        if self.current_branch:
            try:
                # If the tag is annotated, it points to a tag object, not
                # directly to a commit. You need to resolve it to the
                # commit it points to. Using `git rev-parse
                # <tagname>^{commit}` allows getting the right revision.
                commit_ref = self._git_rev_parse_verify(self.data["revision"]
                                                        + "^{commit}")[0]
                self.branch_commit_ref = commit_ref.strip()
            except GitRevisionDoesNotExist:
                pass

    def _repo_delete(self):
        if not self.git_local_dir.exists():
            self.message(self.indent_spaces + "[INFO] Already deleted\n")
        elif not self.git_local_dir.joinpath(".git").is_dir():
            self.message(
                self.indent_spaces
                + f"# Cannot be deleted because '{self.git_local_dir}' is "
                "not a Git repository\n"
            )
            self.set_error(True)
        elif self.git_local_dir.is_dir():
            shutil.rmtree(str(self.git_local_dir))
            self.message(self.indent_spaces
                         + f"[INFO] Deleted: '{self.git_local_dir}'")
            self.set_changed(True)

    def _repo_clone(self):
        git_clone_args = self.data["git_clone_args"]
        # git_clone_args += ["--recurse-submodules"]

        cmd = ["git", "clone"] + git_clone_args + \
            [self.data[self.repo_uri_key], str(self.git_local_dir)]
        self._run(cmd, cwd=".")
        self.set_changed(True)

    def _repo_fetch(self):
        # Merge
        do_git_fetch = self.data["git_pull"]
        do_git_fetch = False

        try:
            # Check if the revision such as
            _, _ = self._run(["git", "cat-file", "-e", self.data["revision"]])
        except subprocess.CalledProcessError:
            do_git_fetch = True
            self.message(
                self.indent_spaces
                + "[INFO] Git fetch origin reason: "
                + f"The revision does not exist: {self.data['revision']}"
                + "\n")

        # The revision exists, but if it a branch, git pull anyway
        if not do_git_fetch:
            try:
                # Check if the branch is a tag or a branch
                cmd = ["git", "show-ref", "--verify", "--quiet",
                       f"refs/heads/{self.data['revision']}"]
                self._run(cmd)
                self.message(
                    self.indent_spaces
                    + "[INFO] Git fetch origin reason: "
                    + f"{self.data['revision']} is a branch, not a tag"
                    + "\n")
                do_git_fetch = True
            except subprocess.CalledProcessError:
                pass

        if not do_git_fetch:
            self.message(self.indent_spaces + "[INFO] git fetch ignored\n")
            return False

        # Fetch
        self._git_fetch_origin()
        return True

    def _git_merge(self):
        git_merge = False

        # Merge
        real_branch = self._git_is_local_branch("HEAD")
        if real_branch and self.current_branch:
            # TODO: only merge when difference from upstream
            commit_ref_head = self._git_ref(cwd=self.git_local_dir)
            self._run(["git", "merge"] + self.data["git_merge_args"] +
                      [f"origin/{self.current_branch}"])
            git_ref_after_merge = self._git_ref(cwd=self.git_local_dir)
            if commit_ref_head != git_ref_after_merge:
                git_merge = True
                self.set_changed(True)
                self._run(["git", "log",
                           '--pretty=format:"%h %ad %s [%cn]"',
                           "--decorate", "--date=short",
                           f"{commit_ref_head}..{git_ref_after_merge}"])

        return git_merge

    def _git_get_remote_url(self, remote_name: str = "origin") -> str:
        origin_url = ""
        try:
            stdout, _ = self._run(["git", "config",
                                   f"remote.{remote_name}.url"])
            origin_url = stdout[0]
        except (subprocess.CalledProcessError, IndexError) as err:
            raise GitRemoteError(
                f"Failed to get the Git remote url: {remote_name}") from err

        return origin_url

    def _git_set_remote_url(self, url: str,
                            remote_name: str = "origin") -> str:
        origin_url = ""
        try:
            self._run(["git", "remote", "remove", remote_name])
        except subprocess.CalledProcessError:
            # Ignore when it cannot be removed when it does not exist
            pass

        try:
            stdout, _ = self._run(["git", "remote", "add", remote_name, url])
            origin_url = stdout[0]
        except (subprocess.CalledProcessError, IndexError) as err:
            raise GitRemoteError(
                f"Failed to modify the Git remote url: {remote_name}") from err

        return origin_url

    def _git_is_local_branch(self, branch: str) -> bool:
        "Return True if it is a local branch that exists."
        try:
            stdout, _ = self._run(["git", "rev-parse", "--symbolic-full-name",
                                   branch])
            if not stdout:
                return False

            full_branch_name = stdout[0].strip()

            if full_branch_name.startswith("refs/heads/"):
                return True
        except subprocess.CalledProcessError:
            pass

        return False

    def _git_rev_parse_verify(self, revision: str) -> List[str]:
        stdout: List[str] = []
        error = False
        try:
            stdout, _ = self._run(["git", "rev-parse", "--verify", revision])
            if not stdout:
                error = True
        except subprocess.CalledProcessError:
            error = True

        if error:
            raise GitRevisionDoesNotExist(
                f"The revision '{revision}' does not exist.")

        return stdout

    def _repo_fix_branch(self) -> bool:
        git_ref_after_merge = self._git_ref(cwd=self.git_local_dir)
        branch_changed = False
        if self.data["revision"]:
            # We also need tags because sometimes, a branch
            # returns a different commit revision
            git_tags, _ = self._run(["git", "tag", "--points-at", "HEAD"])

            # Also check the commit revision in case
            # branch is a commit revision instead of a tag
            try:
                # Check if the branch exists
                git_ref_branch = self._git_rev_parse_verify(
                    "origin/" + self.data["revision"] + "^{commit}")[0]
            except GitRevisionDoesNotExist:
                # Check if the commit ref exists
                try:
                    git_ref_branch = \
                        self._git_rev_parse_verify(self.data["revision"])[0]
                except GitRevisionDoesNotExist as err:
                    raise GitEnsureError(
                        f"The branch '{self.data['revision']}' "
                        "does not exist.") from err

            if git_ref_after_merge != git_ref_branch and \
                    self.data["revision"] not in git_tags:
                # Update the branch
                self._run(["git", "checkout"] + [self.data["revision"]])
                self.message(self.indent_spaces
                             + "[INFO] Branch changed to "
                             + self.data["revision"] + "\n")
                self.set_changed(True)
                branch_changed = True

                # Read branch again
                self._update_current_branch_name()

        return branch_changed

    def _git_fetch_origin(self):
        # Fetch
        if not self._git_fetch_origin_done:
            cmd = ["git", "fetch"]

            if VERBOSE:
                cmd += ["-v"]

            cmd += ["origin"]
            self._run(cmd)
            self._git_fetch_origin_done = True

    def _repo_fix_remote_origin(self):
        correct_origin_url = self.data[self.repo_uri_key]
        update_remote_origin = False

        try:
            origin_url = self._git_get_remote_url()
            if origin_url != correct_origin_url:
                update_remote_origin = True
        except GitRemoteError:
            update_remote_origin = True

        if update_remote_origin:
            # Update remote
            try:
                self._git_set_remote_url(correct_origin_url)
            except GitRemoteError:
                # TODO handle errors
                return

            # Get the current branch
            if self.current_branch:
                try:
                    self.message(
                        self.indent_spaces
                        + "[INFO] Git fetch origin reason: "
                        f"we need to set the upstream "
                        f"origin to {self.current_branch}"
                        "\n"
                    )
                    self._git_fetch_origin()

                    cmd = ["git", "branch",
                           f"--set-upstream-to=origin/{self.current_branch}"]
                    _, _ = self._run(cmd)
                    # TODO: handle errors
                except subprocess.CalledProcessError as err:
                    raise GitEnsureError(str(err)) from err

    def is_error(self) -> bool:
        return self.error

    def set_error(self, error: bool):
        self.error = error

    def set_output(self, output: str):
        self.output = output

    def add_output(self, output: str):
        self.output += output

    def get_output(self) -> str:
        """Return the output."""
        return str(self.output)

    def is_changed(self) -> bool:
        return bool(self.changed)

    def set_changed(self, changed: bool):
        self.changed = changed

    def get_changed(self) -> bool:
        try:
            return bool(self.changed)
        except KeyError:
            return False

    def _local_task_exec(self, *args, **kwargs):
        stdout = run_indent_str(env=self.env, spaces=self.indent,
                                *args, **kwargs)
        if not stdout.endswith("\n"):
            stdout += "\n"
        self.add_output(stdout)

    def _exec_before(self, cwd: os.PathLike = Path(".")):
        if self.data["delete"]:
            return

        cmd = self.data["exec_before"] \
            if "exec_before" in self.data else None
        if cmd:
            self._local_task_exec(cmd, cwd=str(cwd))

    def _exec_after(self, cwd: os.PathLike = Path(".")):
        if self.data["delete"] or not self.is_changed():
            return

        cmd = self.data["exec_after"] \
            if "exec_after" in self.data else None
        if cmd:
            self._local_task_exec(cmd, cwd=str(cwd))


def parse_args():
    """Parse command-line arguments."""
    usage = "%(prog)s [--clone-from URI] [REPO_LOCAL_DIR]"
    parser = argparse.ArgumentParser(
        description="git-ensure",
        usage=usage
    )

    parser.add_argument(
        "repo_local_dir",
        nargs="?",
        default=".",
        type=str,
        help="Absolute or relative path to the local Git repository directory"
    )

    parser.add_argument(
        "-c",
        "--clone-from",
        default="",
        help="Optional URI of a remote Git repository to clone from"
    )

    return parser.parse_args()


def main():
    """The command-line interface."""
    args = parse_args()
    git_update = GitUpdate(repo_uri=args.clone_from,
                           repo_path=args.repo_local_dir)
    git_update.update()


if __name__ == "__main__":
    main()
