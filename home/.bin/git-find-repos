#!/usr/bin/env python
#
# Author: James Cherti
# URL: https://github.com/jamescherti/jc-dev
#
# Distributed under terms of the MIT license.
#
# Copyright (C) 2004-2026 James Cherti
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

"""
Module for discovering and managing Git repositories.

This script allows for finding Git repositories within a directory structure
and executing commands against them. It supports conditional filtering,
background execution, and sequential foreground execution.
"""

import argparse
import os
import shlex
import shutil
import subprocess
import sys
import textwrap
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from multiprocessing import cpu_count
from pathlib import Path
from typing import List, Optional, Set, Tuple

import colorama


@dataclass
class CommandResult:
    """
    Data class to store the result of a subprocess command execution.

    :param command: The command that was executed.
    :type command: List[str]
    :param returncode: The exit status of the command.
    :type returncode: int
    :param stdout: Standard output content.
    :type stdout: str
    :param stderr: Standard error content.
    :type stderr: str
    """
    command: List[str]
    returncode: int
    stdout: str = ""
    stderr: str = ""


@dataclass
class RepoContext:
    """
    A processed Git repository and its execution states.

    :param path: The absolute path to the repository root.
    :type path: Path
    :param bg_result: The result of the background execution, if any.
    :type bg_result: Optional[CommandResult]
    """
    path: Path
    bg_result: Optional[CommandResult] = None


def git_toplevel(repo_path: Path) -> Optional[Path]:
    """
    Return the absolute path to the top-level directory of a Git repository.

    :param repo_path: Path inside the Git repository.
    :type repo_path: Path
    :return: Path to the repository's top-level directory, or None if not a
             Git repo.
    :rtype: Optional[Path]
    """
    try:
        proc = subprocess.run(
            ["git", "-C", str(repo_path), "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            check=True
        )
        return Path(proc.stdout.strip()).resolve()
    except subprocess.CalledProcessError:
        return None


def git_fd_find_repo(path: Path, max_workers: int) -> Set[Path]:
    """
    Find all Git repositories in 'path' using fd.

    :param path: The root directory to search for Git repositories.
    :type path: Path
    :param max_workers: Maximum number of threads for fd.
    :type max_workers: int
    :return: Set of paths to Git repositories.
    :rtype: Set[Path]
    """
    try:
        # Use fd to find .git directories efficiently
        proc = subprocess.run(
            [
                'fd', '--type', 'd', '--hidden', '--no-ignore',
                '^\\.git$', "--threads", str(max_workers), str(path)
            ],
            capture_output=True,
            text=True,
            check=True
        )
    except (subprocess.CalledProcessError, FileNotFoundError):
        return set()

    # Use a set comprehension to remove duplicates and normalize paths
    # efficiently
    return {
        Path(git_dir).parent.resolve()
        for git_dir in proc.stdout.splitlines()
    }


def git_py_find_repo(root: Path) -> Set[Path]:
    """
    Recursively find all Git repositories under the root path using Python.

    :param root: Directory to search under.
    :type root: Path
    :return: Set of paths to Git repositories.
    :rtype: Set[Path]
    """
    return {
        git_dir.parent.resolve()
        for git_dir in root.rglob(".git")
        if git_dir.is_dir()
    }


def run_command_get_output(repo_path: Path, cmd_str: str,
                           capture: bool = True) -> CommandResult:
    """
    Execute a shell command within a specific directory.

    :param repo_path: The directory in which to execute the command.
    :type repo_path: Path
    :param cmd_str: The command string to execute.
    :type cmd_str: str
    :param capture: Whether to capture stdout/stderr.
    :type capture: bool
    :return: The result of the command execution.
    :rtype: CommandResult
    """
    if not cmd_str:
        return CommandResult(command=[], returncode=0)

    cmd_list = shlex.split(cmd_str)

    # Check if command exists
    if not shutil.which(cmd_list[0]):
        return CommandResult(
            command=cmd_list,
            returncode=127,
            stderr=f"Error: Command not found: '{cmd_list[0]}'\n"
        )

    try:
        proc = subprocess.run(
            cmd_list,
            cwd=repo_path,
            capture_output=capture,
            text=True,
            check=False
        )
        return CommandResult(
            command=cmd_list,
            returncode=proc.returncode,
            stdout=proc.stdout if proc.stdout else "",
            stderr=proc.stderr if proc.stderr else ""
        )
    except KeyboardInterrupt:
        raise
    # TODO: Useless
    # except Exception as err:
    #     return CommandResult(
    #         command=cmd_list,
    #         returncode=1,
    #         stderr=str(err)
    #     )


def format_bg_output(repo_path: Path, result: CommandResult) -> str:
    """
    Format the output of a background command for display.

    :param repo_path: The repository path.
    :type repo_path: Path
    :param result: The execution result.
    :type result: CommandResult
    :return: Formatted string ready for printing.
    :rtype: str
    """
    header = f"{colorama.Fore.YELLOW}[EXEC-BG] {repo_path}"
    cmd_str = " ".join(result.command)
    header += f": {cmd_str}{colorama.Fore.RESET}\n"

    raw_output = result.stdout + result.stderr
    if not raw_output and result.returncode == 0:
        return ""

    indent = " " * 4
    formatted = raw_output.replace("\t", "    ").rstrip()
    if formatted:
        formatted += "\n"

    indented_body = textwrap.indent(formatted, prefix=indent)
    return header + indented_body


def process_repo(repo_path: Path, exec_bg_cmd: Optional[str],
                 if_exec_cmd: Optional[str]) -> Optional[RepoContext]:
    """
    Process a single repository: check conditions and run background commands.

    :param repo_path: The repository path.
    :type repo_path: Path
    :param exec_bg_cmd: Command to execute in background/parallel.
    :type exec_bg_cmd: Optional[str]
    :param if_exec_cmd: Command to check before processing (filter).
    :type if_exec_cmd: Optional[str]
    :return: RepoContext if processed successfully, None if filtered out.
    :rtype: Optional[RepoContext]
    """
    # Filter: if-exec
    if if_exec_cmd:
        # We discard output for the filter check, only caring about exit code
        filter_res = run_command_get_output(repo_path, if_exec_cmd,
                                            capture=True)
        if filter_res.returncode != 0:
            return None

    # Action: exec-bg
    bg_result = None
    if exec_bg_cmd:
        bg_result = run_command_get_output(repo_path, exec_bg_cmd,
                                           capture=True)

    return RepoContext(path=repo_path, bg_result=bg_result)


def discover_repos(directory: Path, max_workers: int) -> Set[Path]:
    """
    Discover Git repositories starting from the given directory.

    :param directory: The root directory for search.
    :type directory: Path
    :param max_workers: Maximum number of threads/workers.
    :type max_workers: int
    :return: A set of repository root paths.
    :rtype: Set[Path]
    """
    # 1. Check if the directory itself is inside a repo
    toplevel = git_toplevel(directory)
    if toplevel:
        return {toplevel}

    # 2. Search subdirectories
    if shutil.which("fd"):
        return git_fd_find_repo(directory, max_workers)

    return git_py_find_repo(directory)


def execute_parallel_tasks(
    repos: Set[Path],
    exec_bg: Optional[str],
    if_exec: Optional[str],
    max_workers: int
) -> List[RepoContext]:
    """
    Run discovery and background execution in parallel.

    :param repos: Set of repositories to process.
    :type repos: Set[Path]
    :param exec_bg: Command string for background execution.
    :type exec_bg: Optional[str]
    :param if_exec: Command string for conditional filtering.
    :type if_exec: Optional[str]
    :param max_workers: Maximum number of threads for execution.
    :type max_workers: int
    :return: List of processed repository contexts.
    :rtype: List[RepoContext]
    """
    results: List[RepoContext] = []

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {
            executor.submit(
                process_repo, repo, exec_bg, if_exec
            ): repo for repo in repos
        }

        for future in as_completed(futures):
            try:
                result = future.result()
                if result:
                    results.append(result)
            except Exception as exc:
                print(f"Generated an exception: {exc}", file=sys.stderr)

    return results


def parse_args() -> argparse.Namespace:
    """
    Parse command-line arguments.

    :return: Parsed arguments.
    :rtype: argparse.Namespace
    """
    parser = argparse.ArgumentParser(
        description="Find git repos and execute commands.",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        "directory",
        type=Path,
        default=Path("."),
        nargs="?",
        help="Root directory to search"
    )
    parser.add_argument(
        "-b", "--exec-bg",
        type=str,
        help="Execute the specified command in the background (parallel)",
        default=None
    )
    parser.add_argument(
        "-e", "--exec",
        type=str,
        dest="exec_cmd",  # Renamed to avoid keyword conflict
        help="Execute the specified command (sequential)",
        default=None
    )
    parser.add_argument(
        "-i", "--if-exec",
        type=str,
        help=("Execute commands only if this check returns exit code 0."),
        default=None
    )
    parser.add_argument(
        "-j", "--jobs",
        type=int,
        dest="max_workers",
        help="Maximum number of processors/workers to use",
        default=(cpu_count() or 1) * 2
    )

    return parser.parse_args()


def print_error_summary(errors: List[Tuple[Path, CommandResult]]) -> int:
    """
    Print a summary of execution errors.

    :param errors: List of tuples containing path and result.
    :type errors: List[Tuple[Path, CommandResult]]
    :return: The final exit code (1 if errors exist, else 0).
    :rtype: int
    """
    if not errors:
        return 0

    print()
    print(f"{colorama.Fore.RED}Errors:{colorama.Fore.RESET}")

    final_errno = 0
    for repo_path, result in errors:
        cmd_display = " ".join(result.command)
        if result.returncode != 0:
            final_errno = 1
            if result.returncode == 127:
                msg = "Command not found"
            else:
                msg = f"errno {result.returncode}"

            print(
                f"{colorama.Fore.RED}  - {repo_path}: {msg}: "
                f"{cmd_display}{colorama.Fore.RESET}"
            )

    return final_errno


def main() -> None:
    """
    The main entry point for the command-line interface.
    """
    colorama.init()
    # Disable git prompting
    os.environ["GIT_TERMINAL_PROMPT"] = "0"

    args = parse_args()

    # 1. Discover Repositories
    repos = discover_repos(args.directory.resolve(), args.max_workers)

    # 2. Parallel Processing (Filter + Background Exec)
    processed_repos = execute_parallel_tasks(
        repos,
        args.exec_bg,
        args.if_exec,
        args.max_workers
    )

    execution_errors: List[Tuple[Path, CommandResult]] = []

    # 3. Main Loop: Display results and run sequential commands
    for context in processed_repos:
        repo_path = context.path

        # Handle Background Execution Results
        if context.bg_result:
            output_display = format_bg_output(repo_path, context.bg_result)
            if output_display:
                print(output_display, end="")

            if context.bg_result.returncode != 0:
                execution_errors.append((repo_path, context.bg_result))

        # Handle Foreground Execution
        if args.exec_cmd:
            print(
                f"{colorama.Fore.YELLOW}[EXEC] {repo_path}: "
                f"{args.exec_cmd}{colorama.Fore.RESET}"
            )

            # Run interactively/sequentially (capture=False allows interaction)
            # However, for consistency with error tracking, we might want to
            # capture. Usually --exec implies seeing output immediately.
            try:
                # We use subprocess.check_call to allow direct stdout/stderr
                # flow unless we want to capture for error summary. To match
                # previous logic, we let it flow to stdout.
                subprocess.check_call(
                    shlex.split(args.exec_cmd),
                    cwd=repo_path
                )
            except subprocess.CalledProcessError as err:
                # Construct a dummy result for the error summary
                failed_res = CommandResult(
                    command=shlex.split(args.exec_cmd),
                    returncode=err.returncode
                )
                execution_errors.append((repo_path, failed_res))
            except FileNotFoundError:
                failed_res = CommandResult(
                    command=shlex.split(args.exec_cmd),
                    returncode=127
                )
                execution_errors.append((repo_path, failed_res))

        # If no commands were run, just list the repo
        if not args.exec_cmd and not args.exec_bg:
            print(repo_path)

    # 4. Final Error Summary
    sys.exit(print_error_summary(execution_errors))


if __name__ == "__main__":
    try:
        main()
    except (KeyboardInterrupt, BrokenPipeError):
        print("\nInterrupting...", file=sys.stderr)
        sys.exit(1)
