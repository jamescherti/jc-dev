#!/usr/bin/env python3
#
# Author: James Cherti
# URL: https://github.com/jamescherti/jc-dev
#
# Distributed under terms of the MIT license.
#
# Copyright (C) 2004-2026 James Cherti
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

"""Automation the installation of various types of projects.

The smart-install script automates the installation and setup of various types
of projects by intelligently handling different project structures and
configurations.

It supports Python packages, Vim plugins, and Emacs packages, and includes
mechanisms to deal with read-only directories when using pip.
"""

import os
import shutil
import subprocess
import sys
from pathlib import Path
from tempfile import NamedTemporaryFile, TemporaryDirectory
from typing import List


def run(command: List[str]):
    """Execute a command in a subprocess.

    This function prints the command to be executed and then runs it in a
    subprocess. It raises an exception if the command returns a non-zero exit
    status.

    :param command: A list of strings representing the command and its
                    arguments. For example, ["ls", "-l"].
    """
    print("[RUN]", *command)
    return subprocess.run(command, check=True)


def is_directory_writable(directory: os.PathLike) -> bool:
    """Check if the specified directory is writable.
    This function attempts to create and delete a temporary file in that
    directory.

    :param directory: Path object representing the directory to check.
    :return: True if the directory is writable, False otherwise.
    """
    directory = Path(directory)
    if not directory.is_dir():
        return False

    try:
        with NamedTemporaryFile(dir=directory, delete=True) as temp_file:
            temp_file.write(b'test')
            temp_file.flush()  # Ensure the content is written to disk

        return True
    except (OSError, IOError):
        return False


def pip_install(directory: os.PathLike):
    """Install a Python package using pip from the specified directory.

    This function changes to the given directory, constructs the appropriate
    pip install command based on the environment, and then executes it. After
    installation, it returns to the original working directory.

    :param directory: The directory containing the Python package to install.
    """
    saved_cwd = Path.cwd()
    try:
        directory = Path(directory).resolve()
        os.chdir(directory)

        cmd = ["pip", "install"]
        if not os.environ.get("VIRTUAL_ENV"):
            cmd += ["--user"]
            if shutil.which("emerge"):
                cmd += ["--break-system-packages"]

        cmd += ["."]
        run(cmd)
    finally:
        os.chdir(saved_cwd)


def smart_install_python(project_dir: os.PathLike) -> bool:
    """Install a Python package from the specified directory.

    This function attempts to install a Python package located in the specified
    directory. It first checks if the directory is writable and, if so, runs
    any available test script and installs the package directly. If the
    directory is read-only, it copies the project to a temporary directory and
    performs the installation from there to avoid errors related to write
    permissions.

    :param project_dir: The directory containing the Python package to install.
    :return: True if the installation process is successful, False otherwise.
    """
    test_script = "./run_tests.sh"
    os.chdir(project_dir)

    # Pip install
    if is_directory_writable(project_dir):
        if os.path.isfile(test_script) and os.access(test_script, os.X_OK):
            run([test_script])

        pip_install(project_dir)
        return True

    # Handle read-only directories
    with TemporaryDirectory() as tmpdir:
        if os.path.isfile(test_script) and os.access(test_script, os.X_OK):
            print("[INFO] Tests ignored because the directory is read-only")

        # Copy the project to a temporary directory to avoid pip errors when
        # the original directory is read-only. Pip requires write access to
        # create directories like 'build/', and will fail with an error (e.g.,
        # "ERROR: Failed building wheel") if it cannot do so.
        print(
            f"[INFO] COPYING the read-only {project_dir} to a "
            "temporary directory..."
        )
        shutil.copytree(project_dir, tmpdir, dirs_exist_ok=True,
                        symlinks=True)

        pip_install(Path(tmpdir))
        return True


def rsync(source: os.PathLike, dest: os.PathLike):
    """Synchronize files/directories using rsync.

    This function uses the `rsync` command to synchronize the contents of the
    source path with the destination path. It handles both files and
    directories, ensuring that the destination reflects the source directory's
    state. The synchronization includes deletion of files at the destination
    that no longer exist at the source.

    :param source: The source path to synchronize from. This can be a file or
                   directory.
    :param dest: The destination path to synchronize to. This can be a file or
                 directory.
    """
    source = Path(source).resolve()
    dest = Path(dest).resolve()

    source_str = f"{source}{os.path.sep}" \
        if source.is_dir() else str(source)
    dest_str = f"{dest}{os.path.sep}" \
        if dest.is_dir() else str(dest)

    run(["rsync", "-a", "--delete", source_str, dest_str])


def smart_install_ansible_role(project_name: str) -> bool:
    "Install a Vim plugin that is located in the current directory"
    dest = Path.home() / "src/wip/ansible/roles" / \
        project_name.replace("ansible-role-", "")
    rsync(Path(".").resolve(), dest)
    return True


def smart_install_vim(project_name: str) -> bool:
    "Install a Vim plugin that is located in the current directory"
    if Path("doc").is_dir():
        run(["vim", "-u", "NONE", "-c", "helptags ./doc", "-c", "q"])

    dest = Path.home() / ".vim_bundle/packpath/pack/git-plugins/start" / \
        project_name
    rsync(Path(".").resolve(), dest)
    return True


def smart_install_emacs_package(project_name: str) -> bool:
    "Install an Emacs package that is located in the current directory."
    dest = Path.home() / ".emacs.d/lisp/packages" / project_name
    rsync(Path(".").resolve(), dest)
    return True


def ext_exists(ext: str, recursive: bool = True) -> bool:
    """Check if any file with the given extension exist.
    It check if the extension exists in the current directory or
    subdirectories.

    :param ext: The file extension to search for (e.g., 'el' for '*.el').
    :param recursive: If False, search in the current directory.
                      If True, search recursively in subdirectories.
                      Defaults to True.
    :return: True if any file with the specified extension exists, False
             otherwise.
    """
    pattern = f'**/*.{ext}' if recursive else f'*.{ext}'
    return any(Path('.').glob(pattern))


def smart_install(path: os.PathLike) -> bool:
    "Intelligently install various types of projects."
    path = Path(path).resolve()
    if Path(path).is_file():
        path = Path(path).parent

    os.chdir(path)
    previous_cwd = None
    while True:
        cwd = Path.cwd().resolve()
        if cwd == previous_cwd:
            break
        previous_cwd = cwd

        if cwd == Path.home():
            break

        # print("[TRY DIR]", cwd)
        project_name = cwd.name
        if not project_name:
            # Error
            break

        # 1: install.sh
        # TODO: Use a list of rules instead of hard-coding the rules
        if Path("install.sh").is_file():
            run(["./install.sh"])
            return True

        elif Path("jc-xfce-settings.sh").is_file():
            run(["./jc-xfce-settings.sh"])
            return True

        # 2: Python
        elif (Path("setup.py").is_file()
              or Path("pyproject.toml").is_file()) and ext_exists("py"):
            return smart_install_python(cwd)

        # 3: Vim plugins
        elif Path("README.md").is_file() and \
                (Path("colors").is_dir() or Path("plugin").is_dir()
                 or Path("autoload").is_dir()) and ext_exists("vim"):
            return smart_install_vim(project_name)

        elif Path("tasks/main.yml").is_file() or \
                Path("tasks/main.yaml").is_file():
            return smart_install_ansible_role(project_name)

        # 4: Emacs packages
        # ChangeLog.1 is the Emacs source code
        elif (not Path("ChangeLog.1").is_file()
              and (Path("README").is_file()
                   or Path("README.org").is_file() or Path("COPYING").is_file()
                   or Path("README.md").is_file()) and
                ext_exists("el", False)):
            return smart_install_emacs_package(project_name)

        if Path(".git").is_dir():
            break

        os.chdir("..")

    print(f"{sys.argv[0]}: project type not supported: '{path}'",
          file=sys.stderr)
    return False


def command_line_interface(list_dirs):
    "The command-line interface."
    if not list_dirs:
        list_dirs = ["."]

    for path in list_dirs:
        if not os.path.exists(path):
            print(f"{sys.argv[0]}: no such file or directory: {path}",
                  file=sys.stderr)
            sys.exit(1)

    errno = 0
    for path in list_dirs:
        if list_dirs:
            print("[SMART-INSTALL]", path)

        cwd = Path.cwd()
        try:
            if not smart_install(path):
                errno = 1
        finally:
            if cwd != Path.cwd():
                os.chdir(cwd)

        print()

    sys.exit(errno)


if __name__ == "__main__":
    command_line_interface(sys.argv[1:])
