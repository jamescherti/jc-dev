#!/usr/bin/env bash
#
# Author: James Cherti
# URL: https://github.com/jamescherti/jc-dev
#
# Distributed under terms of the MIT license.
#
# Copyright (C) 2004-2026 James Cherti
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

# When exiting tools like the Python REPL using Ctrl+D, it is easy to press it
# one too many times, sending an End-of-File (EOF) signal to Bash, which logs
# you out immediately.
#
# Fix: Set the IGNOREEOF variable to require multiple Ctrl+D presses before the
# shell exits. Add this to your ~/.bashrc:
#
# Ignore accidental C-d presses (never quit from EOF)
unset IGNOREEOF

# Ensure your TMOUT is set to your desired timeout in seconds (e.g., 1 hour)
export TMOUT=3600

# Custom function to handle manual Ctrl+D keystrokes
handle_ctrl_d() {
  if [[ -z "$READLINE_LINE" ]]; then
    # If the line is empty, mimic the IGNOREEOF warning and do not exit
    echo "Use 'exit' to leave the shell."
  else
    # If the line is not empty, mimic the default forward-delete behavior
    local len=${#READLINE_LINE}
    if ((READLINE_POINT < len)); then
      local before="${READLINE_LINE:0:READLINE_POINT}"
      local after="${READLINE_LINE:READLINE_POINT+1}"
      READLINE_LINE="${before}${after}"
    fi
  fi
}

# Bind Ctrl+D (\C-d) to the custom shell function
bind -x '"\C-d": handle_ctrl_d'

# Init bashrc improved {{{

# Black="\[\033[0;30m\]"       # Black
# Red="\[\033[0;31m\]"         # Red
# Purple="\[\033[0;35m\]"      # Purple
# Cyan="\[\033[0;36m\]"        # Cyan
# White="\[\033[0;37m\]"       # White
# BBlack="\[\033[1;30m\]"      # Black
# BRed="\[\033[1;31m\]"        # Red
# BGreen="\[\033[1;32m\]"      # Green
# BYellow="\[\033[1;33m\]"     # Yellow
# BBlue="\[\033[1;34m\]"       # Blue
# BPurple="\[\033[1;35m\]"     # Purple
# BCyan="\[\033[1;36m\]"       # Cyan
# BWhite="\[\033[1;37m\]"      # White
# UBlack="\[\033[4;30m\]"      # Black
# URed="\[\033[4;31m\]"        # Red
# UGreen="\[\033[4;32m\]"      # Green
# UYellow="\[\033[4;33m\]"     # Yellow
# UBlue="\[\033[4;34m\]"       # Blue
# UPurple="\[\033[4;35m\]"     # Purple
# UCyan="\[\033[4;36m\]"       # Cyan
# UWhite="\[\033[4;37m\]"      # White
# On_Black="\[\033[40m\]"      # Black
# On_Red="\[\033[41m\]"        # Red
# On_Green="\[\033[42m\]"      # Green
# On_Yellow="\[\033[43m\]"     # Yellow
# On_Blue="\[\033[44m\]"       # Blue
# On_Purple="\[\033[45m\]"     # Purple
# On_Cyan="\[\033[46m\]"       # Cyan
# On_White="\[\033[47m\]"      # White
# IBlack="\[\033[0;90m\]"      # Black
# IRed="\[\033[0;91m\]"        # Red
# IGreen="\[\033[0;92m\]"      # Green
# IYellow="\[\033[0;93m\]"     # Yellow
# IBlue="\[\033[0;94m\]"       # Blue
# IPurple="\[\033[0;95m\]"     # Purple
# ICyan="\[\033[0;96m\]"       # Cyan
# IWhite="\[\033[0;97m\]"      # White
# BIBlack="\[\033[1;90m\]"     # Black
# BIRed="\[\033[1;91m\]"       # Red
# BIGreen="\[\033[1;92m\]"     # Green
# BIYellow="\[\033[1;93m\]"    # Yellow
# BIBlue="\[\033[1;94m\]"      # Blue
# BIPurple="\[\033[1;95m\]"    # Purple
# BICyan="\[\033[1;96m\]"      # Cyan
# BIWhite="\[\033[1;97m\]"     # White
# On_IBlack="\[\033[0;100m\]"  # Black
# On_IRed="\[\033[0;101m\]"    # Red
# On_IGreen="\[\033[0;102m\]"  # Green
# On_IYellow="\[\033[0;103m\]" # Yellow
# On_IBlue="\[\033[0;104m\]"   # Blue
# On_IPurple="\[\033[10;95m\]" # Purple
# On_ICyan="\[\033[0;106m\]"   # Cyan
# On_IWhite="\[\033[0;107m\]"  # White

if [[ $_BASHRC_AFTER_LOADED != '' ]]; then
  return
else
  _BASHRC_AFTER_LOADED=1
fi

INPUTRC=~/.inputrc
# Various variables you might want for your PS1 prompt instead
# shellcheck disable=SC2034
Time12h="\T"
# shellcheck disable=SC2034
Time12a="\@"
# shellcheck disable=SC2034
# shellcheck disable=SC2034
PathFull="\W"
# shellcheck disable=SC2034
NewLine="\n"
# shellcheck disable=SC2034
Jobs="\j"
# End Colors }}}

# Removed: --color=never

_git_wrapper() {
  if type -P so &>/dev/null; then
    local cmd_prefix=()
    local cur_arg
    local key
    local ssh_agent_needed=0
    for cur_arg in "$@"; do
      for key in fetch pull pullall pa cip rcip pullall push up pf p; do
        if [[ $cur_arg = "$key" ]] || [[ $cur_arg = "git $key" ]]; then
          ssh_agent_needed=1
        fi
      done

      if [[ $ssh_agent_needed -ne 0 ]]; then
        local remote_origin
        if remote_origin=$(git config --get remote.origin.url); then
          if [[ $remote_origin == https* ]]; then
            if [[ $cur_arg == pu* ]] && type -P so &>/dev/null; then
              cmd_prefix+=(so)
            fi
          fi

          break
        fi
      fi
    done

    # echo "[RUN]" "${cmd_prefix[@]}" "$@" >&2
    "${cmd_prefix[@]}" "$@"
  else
    echo "[RUN]" "$@"
    "$@"
  fi
}

alias git='_git_wrapper git'
# alias rgit='_git_wrapper git find git'
alias lrgit='_git_wrapper git-finder-exec git'

_gm_wrapper() {
  so git find-repos . --if-exec "sh -c '! git-is-clean'" "$@"
}

_ga_wrapper() {
  so git find-repos . "$@"
}

_bg_git_find_repos_wrapper() {
  local opts=()
  if [[ $# -gt 0 ]]; then
    opts+=(--exec-bg "git $*")
  fi

  so git find-repos . "${opts[@]}"
}

_git_find_repos_wrapper() {
  local opts=()
  if [[ $# -gt 0 ]]; then
    opts+=(--exec "git $*")
  fi

  so git find-repos . "${opts[@]}"
}

alias gm='_gm_wrapper'
alias ga='_ga_wrapper'
alias rgit='_bg_git_find_repos_wrapper'
alias batchfetch='so esa ssh-add-exec batchfetch'
alias release='so esa ssh-add-exec release'

release-twine() {
  errno=0
  pushd . &>/dev/null
  cd "$(command git rev-parse --show-toplevel)" || return 1
  python -m build --no-isolation .
  so twine upload dist/* || errno=1
  popd &>/dev/null || return 1
  return "${errno}"
}

umount-maybe() {
  local dir="$1"
  if mountpoint -q "$dir"; then
    echo "[UMOUNT] $dir"
    sudo udiskie-umount "$dir"
  fi
}

alias mountall='sudo -i /bin/sh -c "/usr/bin/udiskie-mount -a; /usr/bin/udiskie-mount -a"'

# Changed to command
# alias qa='pathaction'
alias qai='so pathaction -t install'

alias_completion() {
  local func_name='alias_completion'
  if [[ $# -lt 2 ]]; then
    echo "Usage: $func_name <cmd> <alias> <alias2> <...>" >&2
    return 1
  fi

  local cmd
  cmd="$1"
  shift

  # Load the completion
  if ! type _completion_loader >/dev/null 2>&1; then
    echo "Error: $func_name: '_completion_loader' was not found." >&2
    return 1
  fi

  _completion_loader "$cmd"

  if ! complete -p "$cmd" >/dev/null; then
    echo "Error: $func_name: 'complete -p $cmd' failed." >&2
    return 1
  fi

  # Add aliases
  local alias
  for alias in "$@"; do
    complete_cmd=$(complete -p "$cmd" 2>/dev/null | sed -e 's/[[:space:]][^[:space:]]\+$//')
    complete_cmd="${complete_cmd} $alias"

    if ! (echo "$complete_cmd" | grep -P '^\s*complete\s' >/dev/null 2>&1); then
      echo "Error: $func_name: alias '$alias': '$complete_cmd' is an invalid command." >&2
      return 1
    fi

    eval "$complete_cmd"
  done

  return 0
}

if type _completion_loader >/dev/null 2>&1; then
  alias_completion ssh s lssh issh
  alias_completion git g
  alias_completion scp iscp
fi

# TODO: move them to bashrc.local?
if [[ -r /usr/share/bash-completion/completions/git ]]; then
  # Arch
  # shellcheck disable=SC1091
  source /usr/share/bash-completion/completions/git
fi
if type __git_complete >/dev/null 2>&1; then
  __git_complete gl _git_log
  __git_complete gd _git_diff

  __git_complete gp _git_push
  __git_complete gpf _git_push

  __git_complete br _git_branch
  __git_complete gb _git_branch

  alias merge="git merge"
  __git_complete merge _git_merge

  alias co="git checkout"
  __git_complete co _git_checkout

  __git_complete squash _git_checkout
  __git_complete sq _git_checkout
  alias squash='git squash'
  alias sq='git squash'
fi

alias yamllint="yamllint -c ~/.yamllint_global.yml"

#-------------------------------------------------------------------------------
# CUSTOM COMPLETION
#-------------------------------------------------------------------------------
# Custom bash-completion _git_checkout function to only
# return local branches and not remote ones when using `git checkout`
_git_checkout() {
  __git_has_doubledash && return

  local dwim_opt="$(__git_checkout_default_dwim_mode)"

  case "$prev" in
  -b | -B | --orphan)
    # Complete local branches (and DWIM branch
    # remote branch names) for an option argument
    # specifying a new branch name. This is for
    # convenience, assuming new branches are
    # possibly based on pre-existing branch names.
    __git_complete_refs $dwim_opt --mode="heads"
    return
    ;;
  *) ;;
  esac

  case "$cur" in
  --conflict=*)
    __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
    ;;
  --*)
    __gitcomp_builtin checkout
    ;;
  *)
    # At this point, we've already handled special completion for
    # the arguments to -b/-B, and --orphan. There are 3 main
    # things left we can possibly complete:
    # 1) a start-point for -b/-B, -d/--detach, or --orphan
    # 2) a remote head, for --track
    # 3) an arbitrary reference, possibly including DWIM names
    #

    if [ -n "$(__git_find_on_cmdline "-b -B -d --detach --orphan")" ]; then
      __git_complete_refs --mode="heads"
    elif [ -n "$(__git_find_on_cmdline "--track")" ]; then
      __git_complete_refs --mode="remote-heads"
    else
      # CUSTOM: Use grep to exclude remote refs
      __git_complete_refs "$dwim_opt" --mode="heads"
    fi
    ;;
  esac
}

switch_to_project() {
  local project
  project=$(cat ~/.projects | fzf) || return 1

  if [[ $project != "" ]]; then
    cd "$project" || return 1
  fi
}

alias p=switch_to_project

if [[ $UID != 0 ]]; then
  TMOUT=300
else
  TMOUT=120
fi

# Reset the SSH agent
SSH_AGENT_PID=""
SSH_AUTH_SOCK=""

loop() {
  if [[ $# -lt 1 ]]; then
    echo "Usage: $0 <command> <args...>" >&2
    return 1
  fi

  while true; do
    "$@"
    errno="$?"
    echo
    echo "Error code: $errno"
    sleep 1
  done
}

if type -P nproc &>/dev/null; then
  _nproc=$(nproc)
  if [[ $_nproc -gt 1 ]]; then
    _nproc=$((_nproc - 1))
  fi
else
  _nproc=""
fi

if [[ $_nproc != "" ]]; then
  # shellcheck disable=SC2139
  alias rg="rg --hidden --no-messages --no-heading --threads $_nproc"
  # shellcheck disable=SC2139
  alias fd="fd --threads $_nproc"
fi

if type -P bat &>/dev/null; then
  alias cat=bat
fi

if type -P eza &>/dev/null; then
  # TODO: use global var
  _jc_better_eza() {
    OPTS=()

    local ls_cmd
    ls_cmd="eza"

    if [[ -n "$TERM" && "$TERM" != "dumb" ]]; then
      OPTS+=(--color=auto)
    fi

    # --long
    # --git
    # --header \
    command "$ls_cmd" "${OPTS[@]}" \
      --group \
      --group-directories-first \
      --ignore-glob=__pycache__ \
      --ignore-glob=*.elc \
      --ignore-glob=*.egg-info \
      "$@"
  }

  alias ls=_jc_better_eza
fi

alias ca=cat

if [[ $OSFAMILY != "" ]]; then
  if [[ -f "main_$OSFAMILY/bin/activate" ]]; then
    # shellcheck disable=SC1090
    source "main_$OSFAMILY/bin/activate"
  fi
fi

alias cip="so cip"
# alias gd='command git ydiff'
# alias gdr="git diff"
# alias cia="git cia"
# alias ci="command git-commitflow"
# alias gd="g d"
# alias cip="git-commitflow --push"

alias gs="git show" # avoid typo

# alias b='gb'
# alias gs='git st'
# alias gst='git st'
# alias t='git st'
# alias st="command git status -s"
# alias memacs=minimal-emacs
# alias real-emacs='command emacs'
# alias emacs=emacs-edit
# alias e=devemacs

# Aliases
alias git-sync-upstream='preload-ssh-agent so git-sync-upstream'
alias git-sync='git-sync-upstream'
alias c=wcalc

alias s='esa ssh-add-exec ssh'
alias home-update="so esa ssh-add-exec home-update"
alias hup=home-update
alias scp="esa ssh-add-exec scp"
alias si=smart-install

if type -P rg >/dev/null 2>&1; then
  alias gr='rg'
else
  alias gr='grep -R -i --no-messages'
fi

path-is-inside-of() {
  local target="$1"
  local base="${2%/}"

  [[ "$target" == "$base" ]] || [[ "$target" == "$base/"* ]]
}

smart-fd() {
  if git rev-parse --is-inside-work-tree &>/dev/null \
    || path-is-inside-of "$PWD" "$HOME/src"; then
    command fd --hidden --ignore "$@"
  else
    command fd --hidden --no-ignore --exclude '.git' "$@"
  fi
}

# alias f='fd --no-ignore'
alias f='smart-fd'
alias fd='smart-fd'
alias virt-manager="ssh-add-all; virt-manager"
alias ls='_jc_better_ls --hide=build --hide=Templates --hide=Desktop'

if type -P git-smartmv >/dev/null 2>&1; then
  alias mv="git-smartmv -w 10 --non-interactive"
fi

alias minimal-emacs='command emacs --init-directory=~/.minimal-emacs.d'
alias me=minimal-emacs

alias e=emacs-edit

is-emacs-server-running() {
  local result
  result=$(emacsclient -e "(+ 1 1)" 2>/dev/null)
  [[ $result = 2 ]] && return 0
  return 1
}

smart-editor() {
  if type -P emacs &>/dev/null \
    && is-emacs-server-running; then
    emacs-edit "$@"
  else
    vim "$@"
  fi
}

alias vim=smart-editor

alias bf="batchfetch"
